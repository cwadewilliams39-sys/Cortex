<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="ConvoIntel">
  <meta name="theme-color" content="#0a0a0f">
  <title>Conversation Intelligence</title>
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body, #root { height: 100%; width: 100%; overflow: hidden; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background-color: #0a0a0f;
      color: #e2e8f0;
      -webkit-font-smoothing: antialiased;
    }
    #root { overflow-y: auto; -webkit-overflow-scrolling: touch; }
    @supports (padding: max(0px)) {
      #root {
        padding-left: max(0px, env(safe-area-inset-left));
        padding-right: max(0px, env(safe-area-inset-right));
        padding-bottom: max(0px, env(safe-area-inset-bottom));
      }
    }
    @keyframes mic-pulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.7); }
      50% { box-shadow: 0 0 0 20px rgba(99, 102, 241, 0); }
    }
    .mic-pulse { animation: mic-pulse 2s infinite; }
    @keyframes pulse-soft {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    .pulse-soft { animation: pulse-soft 2s ease-in-out infinite; }
    @keyframes speaker-flash {
      0% { background-color: rgba(16, 185, 129, 0.3); }
      100% { background-color: transparent; }
    }
    .speaker-flash { animation: speaker-flash 0.5s ease-out; }
  </style>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel" data-type="module">
const { useState, useEffect, useRef, useCallback } = React;

// Utilities
const isSecureContext = () => window.isSecureContext || location.protocol === 'https:' || location.hostname === 'localhost';
const hasGetUserMedia = () => !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
const generateId = () => crypto.randomUUID?.() || Math.random().toString(36).substr(2, 9);
const formatTime = (ms) => {
  const s = Math.floor(ms / 1000);
  return `${Math.floor(s / 60).toString().padStart(2, '0')}:${(s % 60).toString().padStart(2, '0')}`;
};
const formatDate = (d) => new Date(d).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric', hour: '2-digit', minute: '2-digit' });

// ============================================================================
// SPEAKER DIARIZATION - Voice Fingerprinting Engine
// ============================================================================
const SpeakerDiarization = {
  profiles: [],
  
  // Extract voice features from audio analyser
  extractFeatures: (analyser) => {
    const frequencyData = new Uint8Array(analyser.frequencyBinCount);
    const timeData = new Uint8Array(analyser.fftSize);
    analyser.getByteFrequencyData(frequencyData);
    analyser.getByteTimeDomainData(timeData);
    
    // Energy (volume)
    let energy = 0;
    for (let i = 0; i < frequencyData.length; i++) {
      energy += frequencyData[i] * frequencyData[i];
    }
    energy = Math.sqrt(energy / frequencyData.length);
    
    // Spectral centroid (brightness/timbre)
    let weightedSum = 0, sum = 0;
    for (let i = 0; i < frequencyData.length; i++) {
      weightedSum += i * frequencyData[i];
      sum += frequencyData[i];
    }
    const spectralCentroid = sum > 0 ? weightedSum / sum : 0;
    
    // Spectral rolloff (where most energy is)
    const totalEnergy = frequencyData.reduce((a, b) => a + b, 0);
    let cumulativeEnergy = 0, rolloff = 0;
    for (let i = 0; i < frequencyData.length; i++) {
      cumulativeEnergy += frequencyData[i];
      if (cumulativeEnergy >= totalEnergy * 0.85) { rolloff = i; break; }
    }
    
    // Zero crossing rate (voice texture)
    let zeroCrossings = 0;
    for (let i = 1; i < timeData.length; i++) {
      if ((timeData[i] >= 128 && timeData[i - 1] < 128) || (timeData[i] < 128 && timeData[i - 1] >= 128)) {
        zeroCrossings++;
      }
    }
    const zcr = zeroCrossings / timeData.length;
    
    // Estimate pitch via autocorrelation
    const sampleRate = 44100;
    const minPeriod = Math.floor(sampleRate / 500); // max 500Hz
    const maxPeriod = Math.floor(sampleRate / 80);  // min 80Hz
    let bestCorrelation = 0, bestPeriod = 0;
    const centered = Array.from(timeData).map(v => v - 128);
    for (let period = minPeriod; period < Math.min(maxPeriod, centered.length / 2); period++) {
      let correlation = 0;
      for (let i = 0; i < centered.length - period; i++) {
        correlation += centered[i] * centered[i + period];
      }
      correlation /= (centered.length - period);
      if (correlation > bestCorrelation) { bestCorrelation = correlation; bestPeriod = period; }
    }
    const pitch = bestPeriod > 0 ? sampleRate / bestPeriod : 0;
    
    // Band energies (low/mid/high voice characteristics)
    const third = Math.floor(frequencyData.length / 3);
    const lowBand = frequencyData.slice(0, third).reduce((a, b) => a + b, 0) / third;
    const midBand = frequencyData.slice(third, third * 2).reduce((a, b) => a + b, 0) / third;
    const highBand = frequencyData.slice(third * 2).reduce((a, b) => a + b, 0) / (frequencyData.length - third * 2);
    
    return { energy, spectralCentroid, rolloff, zcr, pitch, lowBand, midBand, highBand };
  },
  
  // Calculate distance between two voice profiles
  calculateDistance: (f1, f2) => {
    if (!f1 || !f2) return Infinity;
    const weights = { spectralCentroid: 2.0, pitch: 3.0, rolloff: 1.5, zcr: 1.0, lowBand: 1.5, midBand: 1.0, highBand: 1.5 };
    const normalizers = { spectralCentroid: 100, pitch: 200, rolloff: 50, zcr: 0.2, lowBand: 50, midBand: 50, highBand: 50 };
    let distance = 0;
    for (const key of Object.keys(weights)) {
      const diff = (f1[key] || 0) - (f2[key] || 0);
      distance += weights[key] * Math.pow(diff / (normalizers[key] || 1), 2);
    }
    return Math.sqrt(distance);
  },
  
  // Identify speaker from features, create new profile if needed
  identifySpeaker: (features, threshold = 2.5) => {
    if (!features || features.energy < 5) return null; // silence
    
    let bestMatch = null, bestDistance = Infinity;
    for (const profile of SpeakerDiarization.profiles) {
      const distance = SpeakerDiarization.calculateDistance(features, profile.avgFeatures);
      if (distance < bestDistance) { bestDistance = distance; bestMatch = profile; }
    }
    
    if (bestMatch && bestDistance < threshold) {
      // Update running average
      const n = bestMatch.sampleCount;
      for (const key of Object.keys(bestMatch.avgFeatures)) {
        if (typeof features[key] === 'number') {
          bestMatch.avgFeatures[key] = (bestMatch.avgFeatures[key] * n + features[key]) / (n + 1);
        }
      }
      bestMatch.sampleCount++;
      return bestMatch.id;
    }
    
    // Create new speaker profile
    const newProfile = {
      id: `Speaker ${SpeakerDiarization.profiles.length + 1}`,
      avgFeatures: { ...features },
      sampleCount: 1
    };
    SpeakerDiarization.profiles.push(newProfile);
    return newProfile.id;
  },
  
  reset: () => { SpeakerDiarization.profiles = []; },
  getSpeakers: () => SpeakerDiarization.profiles.map(p => p.id),
  getSpeakerCount: () => SpeakerDiarization.profiles.length
};

// ============================================================================
// NLP ENGINE
// ============================================================================
const NLP = {
  sentiment: (text) => {
    const pos = ['great','good','excellent','amazing','wonderful','love','happy','agree','yes','perfect','awesome','excited','success','win','definitely','absolutely'];
    const neg = ['bad','terrible','awful','hate','disagree','no','wrong','problem','issue','concern','worried','frustrated','disappointed','difficult','fail','risk'];
    const words = text.toLowerCase().split(/\W+/);
    let score = 0;
    words.forEach(w => { if (pos.includes(w)) score += 1; if (neg.includes(w)) score -= 1; });
    const norm = Math.max(-1, Math.min(1, score / Math.max(words.length * 0.1, 1)));
    return { score: norm, label: norm > 0.2 ? 'positive' : norm < -0.2 ? 'negative' : 'neutral' };
  },

  topics: (text) => {
    const stop = new Set(['the','a','an','and','or','but','in','on','at','to','for','of','with','by','from','is','are','was','were','be','been','have','has','had','do','does','did','will','would','could','should','that','this','i','you','he','she','it','we','they','what','which','who','when','where','why','how','all','some','no','not','only','so','than','too','very','just','can','my','your','our','their','about','into','through','during','before','after','again','then','here','there','also','well','now','get','like','know','think','want','need','going','thing','things','yeah','okay','right','sure','mean','really','actually','something']);
    const words = text.toLowerCase().split(/\W+/).filter(w => w.length > 3 && !stop.has(w));
    const freq = {};
    words.forEach(w => freq[w] = (freq[w] || 0) + 1);
    return Object.entries(freq).filter(([_,c]) => c >= 2).sort((a,b) => b[1] - a[1]).slice(0, 8).map(([word, count]) => ({ word, count }));
  },

  questions: (text) => text.split(/[.!?]+/).filter(s => /^(what|who|where|when|why|how|is|are|was|were|do|does|did|can|could|would|should|will|have|has)\b/i.test(s.trim()) || s.includes('?')).map(s => s.trim()),

  actions: (text, speaker) => {
    const patterns = [/(?:i will|i'll|we will|we'll|going to)\s+(.+?)(?:\.|$)/gi, /(?:need to|have to|should)\s+(.+?)(?:\.|$)/gi, /(?:let me|let's)\s+(.+?)(?:\.|$)/gi];
    const items = [];
    patterns.forEach(p => { let m; while ((m = p.exec(text)) !== null) { if (m[1].length > 10 && m[1].length < 200) items.push({ id: generateId(), action: m[1].trim(), owner: speaker || 'Unassigned' }); }});
    return items;
  },

  decisions: (text) => {
    const patterns = [/(?:we decided|agreed to|decision is)\s+(.+?)(?:\.|$)/gi, /(?:let's go with|going with)\s+(.+?)(?:\.|$)/gi];
    const items = [];
    patterns.forEach(p => { let m; while ((m = p.exec(text)) !== null) items.push(m[1].trim()); });
    return items;
  },

  style: (segs) => {
    const text = segs.map(s => s.text).join(' ');
    const words = text.split(/\s+/);
    const sentences = text.split(/[.!?]+/).filter(Boolean);
    const avg = words.length / Math.max(sentences.length, 1);
    const iCount = (text.match(/\bi\b/gi) || []).length;
    const weCount = (text.match(/\bwe\b/gi) || []).length;
    return {
      assertiveness: Math.min(100, Math.round((text.match(/!/g) || []).length * 10 + (iCount / words.length * 500))),
      directnessLevel: Math.min(100, Math.round(100 - avg * 3)),
      collaborativeIndex: Math.round(weCount / Math.max(iCount + weCount, 1) * 100),
      preferredPace: avg < 10 ? 'fast' : avg > 20 ? 'slow' : 'moderate'
    };
  },

  summary: (segs, topics, decisions, actions) => {
    const dur = segs.length > 0 ? Math.round((segs[segs.length - 1].timestamp) / 60000) : 0;
    const speakers = [...new Set(segs.map(s => s.speaker))];
    let sum = `${dur}min with ${speakers.length} speaker${speakers.length !== 1 ? 's' : ''}`;
    if (topics.length) sum += ` on ${topics.slice(0, 3).map(t => t.word).join(', ')}`;
    if (decisions.length) sum += `. ${decisions.length} decision${decisions.length !== 1 ? 's' : ''}`;
    if (actions.length) sum += `, ${actions.length} action${actions.length !== 1 ? 's' : ''}`;
    return sum + '.';
  },

  insights: (seg, profiles) => {
    const insights = [];
    if (!seg) return insights;
    const sent = NLP.sentiment(seg.text);
    if (sent.label === 'negative') insights.push({ type: 'warning', message: 'Negative sentiment', action: 'Acknowledge concerns' });
    if (NLP.questions(seg.text).length > 0) insights.push({ type: 'opportunity', message: 'Question detected', action: 'Provide clear response' });
    if (['agree', 'yes', 'exactly', 'right'].some(w => seg.text.toLowerCase().includes(w))) insights.push({ type: 'opportunity', message: 'Agreement signal', action: 'Good moment for next steps' });
    return insights.slice(0, 3);
  }
};

// Storage
const Storage = {
  get: (k) => { try { return JSON.parse(localStorage.getItem(k)); } catch { return null; }},
  set: (k, v) => { try { localStorage.setItem(k, JSON.stringify(v)); } catch {} },
  sessions: () => Storage.get('ci_sessions') || [],
  saveSessions: (s) => Storage.set('ci_sessions', s),
  profiles: () => Storage.get('ci_profiles') || {},
  saveProfiles: (p) => Storage.set('ci_profiles', p),
  micGranted: () => Storage.get('ci_mic_granted') || false,
  setMicGranted: (v) => Storage.set('ci_mic_granted', v),
  settings: () => Storage.get('ci_settings') || { autoSpeaker: true, myName: 'Speaker 1' },
  saveSettings: (s) => Storage.set('ci_settings', s)
};

// ============================================================================
// MICROPHONE HOOK WITH AUTO SPEAKER DETECTION
// ============================================================================
const useMicrophone = () => {
  const [permission, setPermission] = useState('unknown');
  const [listening, setListening] = useState(false);
  const [level, setLevel] = useState(0);
  const [interim, setInterim] = useState('');
  const [error, setError] = useState(null);
  const [currentSpeaker, setCurrentSpeaker] = useState(null);
  const [speakerChanged, setSpeakerChanged] = useState(false);
  
  const streamRef = useRef(null);
  const ctxRef = useRef(null);
  const analyserRef = useRef(null);
  const recRef = useRef(null);
  const activeRef = useRef(false);
  const frameRef = useRef(null);
  const featureBufferRef = useRef([]);
  const lastSpeakerRef = useRef(null);

  useEffect(() => {
    if (!hasGetUserMedia()) { setPermission('unavailable'); setError('Microphone not available'); return; }
    if (!isSecureContext()) { setPermission('unavailable'); setError('Requires HTTPS'); return; }
    if (Storage.micGranted()) setPermission('granted');
    else setPermission('prompt');
    return () => stopMic();
  }, []);

  const requestPermission = async () => {
    setError(null);
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      stream.getTracks().forEach(t => t.stop());
      setPermission('granted');
      Storage.setMicGranted(true);
      return true;
    } catch (e) {
      setError(e.name === 'NotAllowedError' ? 'Permission denied' : 'Microphone error');
      if (e.name === 'NotAllowedError') setPermission('denied');
      return false;
    }
  };

  const startMic = async (onTranscript, autoSpeakerEnabled = true) => {
    setError(null);
    SpeakerDiarization.reset();
    featureBufferRef.current = [];
    lastSpeakerRef.current = null;
    
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      streamRef.current = stream;
      ctxRef.current = new (window.AudioContext || window.webkitAudioContext)();
      if (ctxRef.current.state === 'suspended') await ctxRef.current.resume();
      
      analyserRef.current = ctxRef.current.createAnalyser();
      analyserRef.current.fftSize = 2048;
      analyserRef.current.smoothingTimeConstant = 0.3;
      
      ctxRef.current.createMediaStreamSource(stream).connect(analyserRef.current);
      activeRef.current = true;
      setListening(true);
      setPermission('granted');
      Storage.setMicGranted(true);
      
      // Audio monitoring & feature extraction
      let sampleCount = 0;
      const updateLevel = () => {
        if (!activeRef.current || !analyserRef.current) return;
        const data = new Uint8Array(analyserRef.current.frequencyBinCount);
        analyserRef.current.getByteFrequencyData(data);
        const avg = data.reduce((a, b) => a + b, 0) / data.length;
        setLevel(Math.min(100, avg * 2));
        
        // Sample features when there's audio
        if (autoSpeakerEnabled && avg > 10) {
          sampleCount++;
          if (sampleCount % 5 === 0) {
            const features = SpeakerDiarization.extractFeatures(analyserRef.current);
            if (features.energy > 5) {
              featureBufferRef.current.push(features);
              if (featureBufferRef.current.length > 20) featureBufferRef.current.shift();
            }
          }
        }
        frameRef.current = requestAnimationFrame(updateLevel);
      };
      updateLevel();
      
      // Speech recognition
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (SR) {
        const rec = new SR();
        rec.continuous = true;
        rec.interimResults = true;
        rec.lang = 'en-US';
        
        rec.onresult = (e) => {
          let final = '', inter = '';
          for (let i = e.resultIndex; i < e.results.length; i++) {
            const transcript = e.results[i][0].transcript;
            if (e.results[i].isFinal) {
              final += transcript;
              // Identify speaker from collected features
              if (autoSpeakerEnabled && featureBufferRef.current.length > 0) {
                const avgFeatures = {};
                const keys = Object.keys(featureBufferRef.current[0]).filter(k => typeof featureBufferRef.current[0][k] === 'number');
                keys.forEach(key => {
                  avgFeatures[key] = featureBufferRef.current.reduce((sum, f) => sum + (f[key] || 0), 0) / featureBufferRef.current.length;
                });
                const speaker = SpeakerDiarization.identifySpeaker(avgFeatures);
                if (speaker) {
                  if (speaker !== lastSpeakerRef.current) {
                    setSpeakerChanged(true);
                    setTimeout(() => setSpeakerChanged(false), 500);
                  }
                  setCurrentSpeaker(speaker);
                  lastSpeakerRef.current = speaker;
                }
                featureBufferRef.current = [];
              }
            } else inter += transcript;
          }
          setInterim(final || inter);
          if (final && onTranscript) onTranscript(final, autoSpeakerEnabled ? lastSpeakerRef.current : null);
        };
        
        rec.onerror = (e) => { if (e.error !== 'no-speech' && e.error !== 'aborted') console.log('Speech error:', e.error); };
        rec.onend = () => { if (activeRef.current) setTimeout(() => { if (activeRef.current) try { rec.start(); } catch {} }, 100); };
        recRef.current = rec;
        rec.start();
      } else setError('Speech recognition not supported');
      return true;
    } catch (e) {
      setError(`Failed: ${e.message}`);
      return false;
    }
  };

  const stopMic = () => {
    activeRef.current = false;
    setListening(false);
    setLevel(0);
    setInterim('');
    setCurrentSpeaker(null);
    if (frameRef.current) cancelAnimationFrame(frameRef.current);
    if (recRef.current) try { recRef.current.stop(); } catch {}
    if (streamRef.current) streamRef.current.getTracks().forEach(t => t.stop());
    if (ctxRef.current) try { ctxRef.current.close(); } catch {}
  };

  return { permission, listening, level, interim, error, currentSpeaker, speakerChanged, requestPermission, startMic, stopMic, getSpeakers: SpeakerDiarization.getSpeakers, getSpeakerCount: SpeakerDiarization.getSpeakerCount };
};

// ============================================================================
// MAIN APP
// ============================================================================
function App() {
  const [tab, setTab] = useState('record');
  const [recording, setRecording] = useState(false);
  const [paused, setPaused] = useState(false);
  const [startTime, setStartTime] = useState(null);
  const [elapsed, setElapsed] = useState(0);
  const [segments, setSegments] = useState([]);
  const [manualSpeaker, setManualSpeaker] = useState('Speaker 1');
  const [manual, setManual] = useState('');
  const [mode, setMode] = useState(() => Storage.micGranted() ? 'voice' : 'manual');
  const [analysis, setAnalysis] = useState({ sentiment: { score: 0, label: 'neutral' }, topics: [], questions: [], actions: [], decisions: [], stats: {} });
  const [insights, setInsights] = useState([]);
  const [sessions, setSessions] = useState([]);
  const [profiles, setProfiles] = useState({});
  const [selected, setSelected] = useState(null);
  const [settings, setSettings] = useState(Storage.settings);

  const mic = useMicrophone();
  const scrollRef = useRef(null);
  const timerRef = useRef(null);

  useEffect(() => { setSessions(Storage.sessions()); setProfiles(Storage.profiles()); setSettings(Storage.settings()); }, []);
  useEffect(() => { if (mic.permission === 'granted') setMode('voice'); }, [mic.permission]);
  useEffect(() => { if (recording && !paused) timerRef.current = setInterval(() => setElapsed(Date.now() - startTime), 1000); else clearInterval(timerRef.current); return () => clearInterval(timerRef.current); }, [recording, paused, startTime]);
  useEffect(() => { if (scrollRef.current) scrollRef.current.scrollTop = scrollRef.current.scrollHeight; }, [segments]);

  useEffect(() => {
    if (segments.length === 0) return;
    const text = segments.map(s => s.text).join(' ');
    const last = segments[segments.length - 1];
    const speakers = [...new Set(segments.map(s => s.speaker))];
    const stats = {};
    speakers.forEach(sp => {
      const segs = segments.filter(s => s.speaker === sp);
      const txt = segs.map(s => s.text).join(' ');
      const totalWords = segments.reduce((sum, s) => sum + s.text.split(/\s+/).length, 0);
      const spWords = txt.split(/\s+/).length;
      stats[sp] = { count: segs.length, words: spWords, pct: Math.round((spWords / totalWords) * 100), sentiment: NLP.sentiment(txt) };
    });
    setAnalysis({
      sentiment: NLP.sentiment(text),
      topics: NLP.topics(text),
      questions: NLP.questions(text),
      actions: segments.flatMap(s => NLP.actions(s.text, s.speaker)),
      decisions: NLP.decisions(text),
      stats
    });
    setInsights(NLP.insights(last, profiles));
  }, [segments, profiles]);

  const addSeg = useCallback((text, autoSpeaker = null) => {
    if (!text.trim()) return;
    const speaker = mode === 'voice' && settings.autoSpeaker && autoSpeaker ? autoSpeaker : manualSpeaker;
    setSegments(p => [...p, { id: generateId(), speaker, text: text.trim(), timestamp: Date.now() - startTime, sentiment: NLP.sentiment(text) }]);
  }, [mode, settings.autoSpeaker, manualSpeaker, startTime]);

  const startRec = async () => {
    setRecording(true); setPaused(false); setStartTime(Date.now()); setElapsed(0); setSegments([]);
    setAnalysis({ sentiment: { score: 0, label: 'neutral' }, topics: [], questions: [], actions: [], decisions: [], stats: {} });
    if (mode === 'voice') { const ok = await mic.startMic((text, speaker) => addSeg(text, speaker), settings.autoSpeaker); if (!ok) setMode('manual'); }
  };

  const stopRec = () => {
    setRecording(false); setPaused(false); mic.stopMic();
    if (segments.length > 0) {
      const sess = { id: generateId(), startTime, endTime: Date.now(), duration: elapsed, segments, analysis: { summary: NLP.summary(segments, analysis.topics, analysis.decisions, analysis.actions), ...analysis }, speakers: [...new Set(segments.map(s => s.speaker))] };
      const updated = [sess, ...sessions]; setSessions(updated); Storage.saveSessions(updated); updateProfiles(segments);
    }
  };

  const togglePause = async () => { if (paused) { setPaused(false); if (mode === 'voice') await mic.startMic((text, speaker) => addSeg(text, speaker), settings.autoSpeaker); } else { setPaused(true); mic.stopMic(); } };

  const updateProfiles = (segs) => {
    const p = { ...profiles };
    [...new Set(segs.map(s => s.speaker))].forEach(sp => {
      const spSegs = segs.filter(s => s.speaker === sp);
      if (!p[sp]) p[sp] = { id: generateId(), name: sp, sessions: [], communicationStyle: {}, topicsDiscussed: {} };
      const style = NLP.style(spSegs);
      if (!Object.keys(p[sp].communicationStyle).length) p[sp].communicationStyle = style;
      else Object.keys(style).forEach(k => { if (typeof style[k] === 'number') p[sp].communicationStyle[k] = Math.round((p[sp].communicationStyle[k] + style[k]) / 2); else p[sp].communicationStyle[k] = style[k]; });
      NLP.topics(spSegs.map(s => s.text).join(' ')).forEach(t => { p[sp].topicsDiscussed[t.word] = (p[sp].topicsDiscussed[t.word] || 0) + t.count; });
      p[sp].sessions.push(Date.now());
    });
    setProfiles(p); Storage.saveProfiles(p);
  };

  const exportMD = (s) => {
    let md = `# Conversation - ${formatDate(s.startTime)}\n\n**Duration:** ${formatTime(s.duration)} | **Speakers:** ${s.speakers.join(', ')}\n\n## Summary\n${s.analysis.summary}\n\n## Topics\n${s.analysis.topics.map(t => `- ${t.word} (√ó${t.count})`).join('\n') || 'None'}\n\n## Actions\n${s.analysis.actions.map(a => `- [ ] ${a.action} ‚Äî ${a.owner}`).join('\n') || 'None'}\n\n## Transcript\n\n`;
    s.segments.forEach(seg => { md += `**${seg.speaker}** [${formatTime(seg.timestamp)}]: ${seg.text}\n\n`; });
    const blob = new Blob([md], { type: 'text/markdown' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `conversation_${Date.now()}.md`; a.click();
  };

  const color = (sp) => ({ 'Speaker 1': '#6366f1', 'Speaker 2': '#ec4899', 'Speaker 3': '#14b8a6', 'Speaker 4': '#f59e0b', 'Speaker 5': '#8b5cf6' }[sp] || '#6b7280');
  const emoji = (l) => l === 'positive' ? 'üòä' : l === 'negative' ? 'üòü' : 'üòê';
  const sentColor = (s) => s > 0.2 ? '#10b981' : s < -0.2 ? '#ef4444' : '#f59e0b';

  return (
    <div style={{ minHeight: '100vh', backgroundColor: '#0a0a0f', color: '#e2e8f0', fontFamily: "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif" }}>
      {/* Header */}
      <header style={{ background: 'linear-gradient(135deg, #1a1a2e, #16213e)', borderBottom: '1px solid rgba(99,102,241,0.2)', padding: '16px 20px', paddingTop: 'max(16px, env(safe-area-inset-top))', position: 'sticky', top: 0, zIndex: 100 }}>
        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
          <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
            <div style={{ width: '40px', height: '40px', borderRadius: '12px', background: 'linear-gradient(135deg, #6366f1, #8b5cf6)', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '20px' }}>üéôÔ∏è</div>
            <div>
              <h1 style={{ fontSize: '18px', fontWeight: '700', margin: 0 }}>Conversation Intelligence</h1>
              <p style={{ fontSize: '12px', color: mic.permission === 'granted' ? '#10b981' : '#94a3b8', margin: 0 }}>
                {mic.permission === 'granted' ? `üü¢ Auto-speaker ${settings.autoSpeaker ? 'ON' : 'OFF'}` : '‚ö™ Enable mic'}
              </p>
            </div>
          </div>
          {recording && (
            <div style={{ display: 'flex', alignItems: 'center', gap: '8px', padding: '8px 16px', backgroundColor: paused ? 'rgba(245,158,11,0.2)' : 'rgba(239,68,68,0.2)', borderRadius: '20px' }}>
              <div style={{ width: '8px', height: '8px', borderRadius: '50%', backgroundColor: paused ? '#f59e0b' : '#ef4444' }} className={paused ? '' : 'pulse-soft'} />
              <span style={{ fontSize: '14px', fontWeight: '600' }}>{formatTime(elapsed)}</span>
            </div>
          )}
        </div>
      </header>

      {/* Tabs */}
      <nav style={{ display: 'flex', backgroundColor: '#111118', borderBottom: '1px solid rgba(99,102,241,0.1)' }}>
        {[{ id: 'record', icon: 'üéôÔ∏è', label: 'Record' }, { id: 'analysis', icon: 'üìä', label: 'Analysis' }, { id: 'history', icon: 'üìÅ', label: 'History' }, { id: 'profiles', icon: 'üë•', label: 'Profiles' }].map(t => (
          <button key={t.id} onClick={() => setTab(t.id)} style={{ flex: 1, padding: '14px 8px', backgroundColor: 'transparent', border: 'none', borderBottom: tab === t.id ? '2px solid #6366f1' : '2px solid transparent', color: tab === t.id ? '#e2e8f0' : '#64748b', fontSize: '13px', fontWeight: '600', cursor: 'pointer' }}>{t.icon} {t.label}</button>
        ))}
      </nav>

      <main style={{ padding: '20px', paddingBottom: '100px' }}>
        {/* RECORD TAB */}
        {tab === 'record' && (
          <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
            
            {/* Current Speaker Indicator */}
            {recording && mode === 'voice' && settings.autoSpeaker && mic.currentSpeaker && (
              <div className={mic.speakerChanged ? 'speaker-flash' : ''} style={{ padding: '12px 16px', backgroundColor: `${color(mic.currentSpeaker)}15`, border: `2px solid ${color(mic.currentSpeaker)}`, borderRadius: '12px', display: 'flex', alignItems: 'center', gap: '12px' }}>
                <div style={{ width: '44px', height: '44px', borderRadius: '50%', backgroundColor: color(mic.currentSpeaker), display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '20px', fontWeight: '700', color: 'white' }}>{mic.currentSpeaker.replace('Speaker ', '')}</div>
                <div>
                  <div style={{ fontWeight: '600', color: color(mic.currentSpeaker), fontSize: '16px' }}>{mic.currentSpeaker} {mic.listening && mic.level > 10 && <span style={{ fontSize: '12px', color: '#10b981' }}>‚óè Speaking</span>}</div>
                  <div style={{ fontSize: '12px', color: '#64748b' }}>{mic.getSpeakerCount()} speaker{mic.getSpeakerCount() !== 1 ? 's' : ''} detected</div>
                </div>
              </div>
            )}
            
            {/* Mic Permission */}
            {mic.permission !== 'granted' && mic.permission !== 'unavailable' && (
              <div style={{ backgroundColor: '#111118', borderRadius: '16px', padding: '32px 24px', border: '2px solid rgba(99,102,241,0.5)', textAlign: 'center' }}>
                <div style={{ fontSize: '64px', marginBottom: '20px' }}>üé§</div>
                <h3 style={{ margin: '0 0 12px', fontSize: '22px', fontWeight: '700' }}>Enable Microphone</h3>
                <p style={{ margin: '0 0 24px', fontSize: '15px', color: '#94a3b8' }}>Voice recording with <strong>automatic speaker detection</strong></p>
                {mic.error && <div style={{ backgroundColor: 'rgba(239,68,68,0.1)', borderRadius: '12px', padding: '12px', marginBottom: '20px', color: '#fca5a5', fontSize: '13px' }}>{mic.error}</div>}
                <button onClick={mic.requestPermission} className="mic-pulse" style={{ padding: '18px 48px', borderRadius: '16px', border: 'none', background: 'linear-gradient(135deg, #6366f1, #8b5cf6)', color: 'white', fontSize: '18px', fontWeight: '700', cursor: 'pointer' }}>üéôÔ∏è Allow Microphone</button>
                <div style={{ marginTop: '24px', paddingTop: '24px', borderTop: '1px solid rgba(99,102,241,0.2)' }}><button onClick={() => setMode('manual')} style={{ padding: '10px 20px', borderRadius: '10px', border: '1px solid rgba(99,102,241,0.3)', backgroundColor: 'transparent', color: '#94a3b8', fontSize: '14px', cursor: 'pointer' }}>Use Manual Input</button></div>
              </div>
            )}

            {/* Controls */}
            <div style={{ backgroundColor: '#111118', borderRadius: '16px', padding: '24px', border: '1px solid rgba(99,102,241,0.2)' }}>
              {/* Auto Speaker Toggle */}
              <div style={{ display: 'flex', gap: '12px', marginBottom: '16px', flexWrap: 'wrap' }}>
                <div style={{ flex: '1', minWidth: '140px' }}>
                  <label style={{ display: 'block', fontSize: '12px', color: '#94a3b8', marginBottom: '6px', fontWeight: '600', textTransform: 'uppercase' }}>Speaker Detection</label>
                  <button onClick={() => { const ns = { ...settings, autoSpeaker: !settings.autoSpeaker }; setSettings(ns); Storage.saveSettings(ns); }} style={{ width: '100%', padding: '10px 12px', borderRadius: '8px', border: `2px solid ${settings.autoSpeaker ? '#10b981' : 'rgba(99,102,241,0.3)'}`, backgroundColor: settings.autoSpeaker ? 'rgba(16,185,129,0.1)' : 'transparent', color: settings.autoSpeaker ? '#10b981' : '#94a3b8', fontSize: '14px', fontWeight: '600', cursor: 'pointer' }}>{settings.autoSpeaker ? 'ü§ñ Auto' : '‚úã Manual'}</button>
                </div>
                <div style={{ flex: '1', minWidth: '140px' }}>
                  <label style={{ display: 'block', fontSize: '12px', color: '#94a3b8', marginBottom: '6px', fontWeight: '600', textTransform: 'uppercase' }}>You Are</label>
                  <select value={settings.myName} onChange={(e) => { const ns = { ...settings, myName: e.target.value }; setSettings(ns); Storage.saveSettings(ns); }} style={{ width: '100%', padding: '10px 12px', borderRadius: '8px', border: '1px solid rgba(99,102,241,0.3)', backgroundColor: '#1e1e2e', color: '#e2e8f0', fontSize: '14px' }}>
                    {(mic.getSpeakers().length > 0 ? mic.getSpeakers() : ['Speaker 1', 'Speaker 2', 'Speaker 3']).map(sp => <option key={sp} value={sp}>{sp}</option>)}
                  </select>
                </div>
              </div>

              {/* Manual Speaker Select */}
              {(!settings.autoSpeaker || mode === 'manual') && (
                <div style={{ marginBottom: '16px' }}>
                  <label style={{ display: 'block', fontSize: '12px', color: '#94a3b8', marginBottom: '6px', fontWeight: '600', textTransform: 'uppercase' }}>Current Speaker</label>
                  <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
                    {['Speaker 1', 'Speaker 2', 'Speaker 3', 'Speaker 4'].map(sp => (
                      <button key={sp} onClick={() => setManualSpeaker(sp)} style={{ padding: '10px 16px', borderRadius: '10px', border: manualSpeaker === sp ? `2px solid ${color(sp)}` : '1px solid rgba(99,102,241,0.3)', backgroundColor: manualSpeaker === sp ? `${color(sp)}20` : 'rgba(30,30,40,0.5)', color: '#e2e8f0', fontSize: '14px', cursor: 'pointer' }}><span style={{ display: 'inline-block', width: '8px', height: '8px', borderRadius: '50%', backgroundColor: color(sp), marginRight: '8px' }} />{sp}</button>
                    ))}
                  </div>
                </div>
              )}

              {/* Mode Toggle */}
              <div style={{ marginBottom: '16px' }}>
                <label style={{ display: 'block', fontSize: '12px', color: '#94a3b8', marginBottom: '6px', fontWeight: '600', textTransform: 'uppercase' }}>Input Mode</label>
                <div style={{ display: 'flex', gap: '8px' }}>
                  <button onClick={() => mic.permission === 'granted' ? setMode('voice') : mic.requestPermission()} style={{ flex: 1, padding: '12px', borderRadius: '10px', border: mode === 'voice' ? '2px solid #6366f1' : '1px solid rgba(99,102,241,0.3)', backgroundColor: mode === 'voice' ? 'rgba(99,102,241,0.1)' : 'transparent', color: '#e2e8f0', textAlign: 'left', cursor: 'pointer' }}><div style={{ fontWeight: '600', fontSize: '14px' }}>üéôÔ∏è Voice {mic.permission === 'granted' && '‚úì'}</div><div style={{ fontSize: '12px', color: '#64748b' }}>Auto speaker detection</div></button>
                  <button onClick={() => setMode('manual')} style={{ flex: 1, padding: '12px', borderRadius: '10px', border: mode === 'manual' ? '2px solid #6366f1' : '1px solid rgba(99,102,241,0.3)', backgroundColor: mode === 'manual' ? 'rgba(99,102,241,0.1)' : 'transparent', color: '#e2e8f0', textAlign: 'left', cursor: 'pointer' }}><div style={{ fontWeight: '600', fontSize: '14px' }}>‚å®Ô∏è Manual</div><div style={{ fontSize: '12px', color: '#64748b' }}>Type + select speaker</div></button>
                </div>
              </div>

              {/* Audio Level */}
              {recording && mode === 'voice' && mic.listening && (
                <div style={{ marginBottom: '16px' }}>
                  <label style={{ display: 'block', fontSize: '12px', color: '#94a3b8', marginBottom: '6px', fontWeight: '600', textTransform: 'uppercase' }}>üé§ Audio Level</label>
                  <div style={{ height: '12px', backgroundColor: '#1e1e2e', borderRadius: '6px', overflow: 'hidden' }}><div style={{ width: `${mic.level}%`, height: '100%', background: mic.level > 70 ? '#ef4444' : mic.level > 40 ? '#f59e0b' : '#10b981', borderRadius: '6px', transition: 'width 0.05s' }} /></div>
                </div>
              )}

              {/* Record Buttons */}
              <div style={{ display: 'flex', justifyContent: 'center', gap: '16px', marginBottom: '16px' }}>
                {!recording ? (
                  <button onClick={startRec} style={{ width: '100px', height: '100px', borderRadius: '50%', border: 'none', background: 'linear-gradient(135deg, #6366f1, #8b5cf6)', color: 'white', fontSize: '36px', cursor: 'pointer', boxShadow: '0 0 40px rgba(99,102,241,0.4)' }}>{mode === 'voice' ? 'üéôÔ∏è' : '‚ñ∂Ô∏è'}</button>
                ) : (
                  <>
                    <button onClick={togglePause} style={{ width: '70px', height: '70px', borderRadius: '50%', border: 'none', backgroundColor: paused ? '#10b981' : '#f59e0b', color: 'white', fontSize: '24px', cursor: 'pointer' }}>{paused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è'}</button>
                    <button onClick={stopRec} style={{ width: '70px', height: '70px', borderRadius: '50%', border: 'none', backgroundColor: '#ef4444', color: 'white', fontSize: '24px', cursor: 'pointer' }}>‚èπÔ∏è</button>
                  </>
                )}
              </div>

              {/* Manual Input */}
              {recording && mode === 'manual' && (
                <form onSubmit={(e) => { e.preventDefault(); if (manual.trim()) { addSeg(manual); setManual(''); }}} style={{ display: 'flex', gap: '8px' }}>
                  <input value={manual} onChange={e => setManual(e.target.value)} placeholder={`Type what ${manualSpeaker} said...`} style={{ flex: 1, padding: '14px 16px', borderRadius: '12px', border: '1px solid rgba(99,102,241,0.3)', backgroundColor: 'rgba(30,30,40,0.5)', color: '#e2e8f0', fontSize: '16px', outline: 'none' }} />
                  <button type="submit" style={{ padding: '14px 24px', borderRadius: '12px', border: 'none', backgroundColor: '#6366f1', color: 'white', fontWeight: '600', cursor: 'pointer' }}>Add</button>
                </form>
              )}

              {/* Interim */}
              {recording && mic.listening && mic.interim && (
                <div style={{ marginTop: '16px', padding: '12px 16px', backgroundColor: 'rgba(99,102,241,0.1)', borderRadius: '10px', borderLeft: `3px solid ${mic.currentSpeaker ? color(mic.currentSpeaker) : '#6366f1'}` }}>
                  <span style={{ fontSize: '12px', color: '#94a3b8' }}>üé§ {mic.currentSpeaker || 'Detecting'}...</span>
                  <p style={{ margin: '4px 0 0', color: '#cbd5e1', fontStyle: 'italic' }}>{mic.interim}</p>
                </div>
              )}
            </div>

            {/* Transcript */}
            {(recording || segments.length > 0) && (
              <div style={{ backgroundColor: '#111118', borderRadius: '16px', padding: '20px', border: '1px solid rgba(99,102,241,0.2)' }}>
                <h3 style={{ fontSize: '14px', fontWeight: '600', color: '#94a3b8', marginBottom: '16px', textTransform: 'uppercase' }}>Transcript ({segments.length}) ‚Ä¢ {[...new Set(segments.map(s => s.speaker))].length} speakers</h3>
                <div ref={scrollRef} style={{ maxHeight: '300px', overflowY: 'auto', display: 'flex', flexDirection: 'column', gap: '10px' }}>
                  {segments.map(s => (
                    <div key={s.id} style={{ padding: '12px 16px', backgroundColor: 'rgba(30,30,40,0.5)', borderRadius: '12px', borderLeft: `3px solid ${color(s.speaker)}` }}>
                      <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '6px' }}>
                        <span style={{ fontWeight: '600', color: color(s.speaker), fontSize: '13px' }}>{s.speaker}</span>
                        <span style={{ fontSize: '11px', color: '#64748b' }}>{formatTime(s.timestamp)} {emoji(s.sentiment?.label)}</span>
                      </div>
                      <p style={{ margin: 0, fontSize: '15px', color: '#e2e8f0' }}>{s.text}</p>
                    </div>
                  ))}
                  {segments.length === 0 && <p style={{ textAlign: 'center', color: '#64748b', padding: '40px 0' }}>{recording ? (mode === 'voice' ? 'üé§ Listening for speakers...' : '‚å®Ô∏è Type to add...') : 'No transcript'}</p>}
                </div>
              </div>
            )}

            {/* Insights */}
            {recording && insights.length > 0 && (
              <div style={{ backgroundColor: '#111118', borderRadius: '16px', padding: '20px', border: '1px solid rgba(16,185,129,0.3)' }}>
                <h3 style={{ fontSize: '14px', fontWeight: '600', color: '#10b981', marginBottom: '12px' }}>üéØ Insights</h3>
                {insights.map((ins, i) => (
                  <div key={i} style={{ padding: '10px 14px', backgroundColor: 'rgba(30,30,40,0.5)', borderRadius: '10px', borderLeft: `3px solid ${ins.type === 'warning' ? '#ef4444' : '#10b981'}`, marginBottom: '8px' }}>
                    <div style={{ fontWeight: '600', fontSize: '13px', color: '#e2e8f0' }}>{ins.type === 'warning' ? '‚ö†Ô∏è' : '‚ú®'} {ins.message}</div>
                    <div style={{ fontSize: '13px', color: '#10b981' }}>‚Üí {ins.action}</div>
                  </div>
                ))}
              </div>
            )}
          </div>
        )}

        {/* ANALYSIS TAB */}
        {tab === 'analysis' && (
          <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
            <div style={{ backgroundColor: '#111118', borderRadius: '16px', padding: '24px', border: '1px solid rgba(99,102,241,0.2)', textAlign: 'center' }}>
              <h3 style={{ fontSize: '14px', color: '#94a3b8', marginBottom: '12px', textTransform: 'uppercase' }}>Overall Sentiment</h3>
              <div style={{ fontSize: '56px' }}>{emoji(analysis.sentiment.label)}</div>
              <div style={{ fontSize: '20px', fontWeight: '700', color: sentColor(analysis.sentiment.score) }}>{analysis.sentiment.label.toUpperCase()}</div>
            </div>
            
            <div style={{ backgroundColor: '#111118', borderRadius: '16px', padding: '24px', border: '1px solid rgba(99,102,241,0.2)' }}>
              <h3 style={{ fontSize: '14px', color: '#94a3b8', marginBottom: '16px', textTransform: 'uppercase' }}>Speaker Stats</h3>
              {Object.entries(analysis.stats).map(([sp, st]) => (
                <div key={sp} style={{ padding: '16px', backgroundColor: 'rgba(30,30,40,0.5)', borderRadius: '12px', borderLeft: `3px solid ${color(sp)}`, marginBottom: '12px' }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '8px' }}>
                    <span style={{ fontWeight: '600', color: color(sp) }}>{sp}</span>
                    <span style={{ fontSize: '24px' }}>{emoji(st.sentiment?.label)}</span>
                  </div>
                  <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '8px', textAlign: 'center' }}>
                    <div><div style={{ fontSize: '18px', fontWeight: '700' }}>{st.count}</div><div style={{ fontSize: '11px', color: '#64748b' }}>Segments</div></div>
                    <div><div style={{ fontSize: '18px', fontWeight: '700' }}>{st.words}</div><div style={{ fontSize: '11px', color: '#64748b' }}>Words</div></div>
                    <div><div style={{ fontSize: '18px', fontWeight: '700' }}>{st.pct}%</div><div style={{ fontSize: '11px', color: '#64748b' }}>Talk Time</div></div>
                  </div>
                </div>
              ))}
              {Object.keys(analysis.stats).length === 0 && <p style={{ textAlign: 'center', color: '#64748b' }}>No data yet</p>}
            </div>
            
            <div style={{ backgroundColor: '#111118', borderRadius: '16px', padding: '24px', border: '1px solid rgba(99,102,241,0.2)' }}>
              <h3 style={{ fontSize: '14px', color: '#94a3b8', marginBottom: '16px', textTransform: 'uppercase' }}>Topics</h3>
              <div style={{ display: 'flex', flexWrap: 'wrap', gap: '10px' }}>
                {analysis.topics.map((t, i) => <span key={i} style={{ padding: '8px 16px', backgroundColor: 'rgba(99,102,241,0.15)', borderRadius: '20px', fontSize: '14px' }}>{t.word} <span style={{ color: '#6366f1' }}>√ó{t.count}</span></span>)}
                {analysis.topics.length === 0 && <p style={{ color: '#64748b', width: '100%', textAlign: 'center' }}>Topics appear as you talk</p>}
              </div>
            </div>
            
            <div style={{ backgroundColor: '#111118', borderRadius: '16px', padding: '24px', border: '1px solid rgba(99,102,241,0.2)' }}>
              <h3 style={{ fontSize: '14px', color: '#94a3b8', marginBottom: '16px', textTransform: 'uppercase' }}>Action Items ({analysis.actions.length})</h3>
              {analysis.actions.map((a, i) => (
                <div key={i} style={{ padding: '12px 16px', backgroundColor: 'rgba(30,30,40,0.5)', borderRadius: '10px', marginBottom: '8px', borderLeft: `3px solid ${color(a.owner)}` }}>
                  <p style={{ margin: 0, fontSize: '14px' }}>{a.action}</p>
                  <span style={{ display: 'inline-block', marginTop: '6px', padding: '4px 10px', borderRadius: '12px', fontSize: '12px', backgroundColor: `${color(a.owner)}20`, color: color(a.owner) }}>{a.owner}</span>
                </div>
              ))}
              {analysis.actions.length === 0 && <p style={{ textAlign: 'center', color: '#64748b' }}>Action items extracted automatically</p>}
            </div>
          </div>
        )}

        {/* HISTORY TAB */}
        {tab === 'history' && (
          <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
            {selected ? (
              <>
                <button onClick={() => setSelected(null)} style={{ padding: '10px 16px', backgroundColor: 'transparent', border: '1px solid rgba(99,102,241,0.3)', borderRadius: '10px', color: '#6366f1', fontSize: '14px', cursor: 'pointer', alignSelf: 'flex-start' }}>‚Üê Back</button>
                <div style={{ backgroundColor: '#111118', borderRadius: '16px', padding: '24px', border: '1px solid rgba(99,102,241,0.2)' }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', flexWrap: 'wrap', gap: '12px', marginBottom: '20px' }}>
                    <div><h2 style={{ margin: 0, fontSize: '18px' }}>{formatDate(selected.startTime)}</h2><p style={{ margin: '4px 0 0', fontSize: '14px', color: '#64748b' }}>{formatTime(selected.duration)} ‚Ä¢ {selected.speakers.join(', ')}</p></div>
                    <button onClick={() => exportMD(selected)} style={{ padding: '8px 16px', backgroundColor: '#6366f1', border: 'none', borderRadius: '8px', color: 'white', fontSize: '13px', fontWeight: '600', cursor: 'pointer' }}>üìÑ Export</button>
                  </div>
                  <div style={{ padding: '16px', backgroundColor: 'rgba(30,30,40,0.5)', borderRadius: '12px', marginBottom: '16px' }}><h4 style={{ margin: '0 0 8px', fontSize: '13px', color: '#94a3b8', textTransform: 'uppercase' }}>Summary</h4><p style={{ margin: 0, fontSize: '15px', lineHeight: '1.6' }}>{selected.analysis.summary}</p></div>
                  <h4 style={{ margin: '0 0 12px', fontSize: '13px', color: '#94a3b8', textTransform: 'uppercase' }}>Transcript</h4>
                  {selected.segments.map(s => (
                    <div key={s.id} style={{ padding: '12px 16px', backgroundColor: 'rgba(30,30,40,0.5)', borderRadius: '10px', borderLeft: `3px solid ${color(s.speaker)}`, marginBottom: '8px' }}>
                      <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '4px' }}><span style={{ fontWeight: '600', color: color(s.speaker), fontSize: '13px' }}>{s.speaker}</span><span style={{ fontSize: '11px', color: '#64748b' }}>{formatTime(s.timestamp)}</span></div>
                      <p style={{ margin: 0, fontSize: '14px' }}>{s.text}</p>
                    </div>
                  ))}
                </div>
              </>
            ) : (
              <>
                <h2 style={{ fontSize: '20px', fontWeight: '700', margin: 0 }}>History</h2>
                <p style={{ fontSize: '14px', color: '#64748b', margin: '0 0 12px' }}>{sessions.length} sessions</p>
                {sessions.map(s => (
                  <div key={s.id} onClick={() => setSelected(s)} style={{ backgroundColor: '#111118', borderRadius: '16px', padding: '20px', border: '1px solid rgba(99,102,241,0.2)', cursor: 'pointer' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                      <div><h3 style={{ margin: '0 0 4px', fontSize: '16px' }}>{formatDate(s.startTime)}</h3><p style={{ margin: 0, fontSize: '13px', color: '#64748b' }}>{formatTime(s.duration)} ‚Ä¢ {s.speakers.join(', ')}</p></div>
                      <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                        <span style={{ fontSize: '24px' }}>{emoji(s.analysis.sentiment.label)}</span>
                        <button onClick={(e) => { e.stopPropagation(); if (confirm('Delete?')) { const u = sessions.filter(x => x.id !== s.id); setSessions(u); Storage.saveSessions(u); }}} style={{ padding: '6px 10px', backgroundColor: 'rgba(239,68,68,0.1)', border: '1px solid rgba(239,68,68,0.3)', borderRadius: '6px', color: '#ef4444', fontSize: '12px', cursor: 'pointer' }}>üóëÔ∏è</button>
                      </div>
                    </div>
                    <p style={{ margin: '12px 0 0', fontSize: '14px', color: '#94a3b8', overflow: 'hidden', textOverflow: 'ellipsis', display: '-webkit-box', WebkitLineClamp: 2, WebkitBoxOrient: 'vertical' }}>{s.analysis.summary}</p>
                  </div>
                ))}
                {sessions.length === 0 && <div style={{ backgroundColor: '#111118', borderRadius: '16px', padding: '60px 20px', border: '1px solid rgba(99,102,241,0.2)', textAlign: 'center' }}><div style={{ fontSize: '48px', marginBottom: '16px' }}>üìÅ</div><h3 style={{ margin: '0 0 8px' }}>No Sessions</h3><p style={{ margin: 0, color: '#64748b', fontSize: '14px' }}>Start recording to save sessions</p></div>}
              </>
            )}
          </div>
        )}

        {/* PROFILES TAB */}
        {tab === 'profiles' && (
          <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
            <h2 style={{ fontSize: '20px', fontWeight: '700', margin: 0 }}>Speaker Profiles</h2>
            <p style={{ fontSize: '14px', color: '#64748b', margin: '0 0 12px' }}>Built from conversations</p>
            {Object.entries(profiles).map(([name, p]) => (
              <div key={p.id} style={{ backgroundColor: '#111118', borderRadius: '16px', padding: '24px', border: '1px solid rgba(99,102,241,0.2)' }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: '16px', marginBottom: '20px' }}>
                  <div style={{ width: '56px', height: '56px', borderRadius: '50%', backgroundColor: color(name), display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '24px', fontWeight: '700', color: 'white' }}>{name.charAt(0)}</div>
                  <div><h3 style={{ margin: 0, fontSize: '18px' }}>{name}</h3><p style={{ margin: '4px 0 0', fontSize: '13px', color: '#64748b' }}>{p.sessions?.length || 0} sessions</p></div>
                </div>
                {p.communicationStyle && Object.keys(p.communicationStyle).length > 0 && (
                  <div style={{ marginBottom: '20px' }}>
                    <h4 style={{ margin: '0 0 12px', fontSize: '13px', color: '#94a3b8', textTransform: 'uppercase' }}>Style</h4>
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '12px' }}>
                      {['assertiveness', 'directnessLevel', 'collaborativeIndex'].map(k => (
                        <div key={k}>
                          <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '4px' }}><span style={{ fontSize: '12px', color: '#94a3b8', textTransform: 'capitalize' }}>{k.replace(/([A-Z])/g, ' $1')}</span><span style={{ fontSize: '12px', fontWeight: '600' }}>{p.communicationStyle[k] || 0}%</span></div>
                          <div style={{ height: '6px', backgroundColor: '#1e1e2e', borderRadius: '3px', overflow: 'hidden' }}><div style={{ width: `${p.communicationStyle[k] || 0}%`, height: '100%', backgroundColor: '#6366f1', borderRadius: '3px' }} /></div>
                        </div>
                      ))}
                      <div><span style={{ fontSize: '12px', color: '#94a3b8' }}>Pace</span><div style={{ marginTop: '4px', padding: '6px 12px', backgroundColor: 'rgba(99,102,241,0.15)', borderRadius: '6px', fontSize: '13px', display: 'inline-block', textTransform: 'capitalize' }}>{p.communicationStyle.preferredPace || 'Unknown'}</div></div>
                    </div>
                  </div>
                )}
                {p.topicsDiscussed && Object.keys(p.topicsDiscussed).length > 0 && (
                  <div>
                    <h4 style={{ margin: '0 0 8px', fontSize: '13px', color: '#94a3b8', textTransform: 'uppercase' }}>Top Topics</h4>
                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px' }}>
                      {Object.entries(p.topicsDiscussed).sort((a, b) => b[1] - a[1]).slice(0, 5).map(([word, count], i) => (
                        <span key={i} style={{ padding: '4px 10px', backgroundColor: 'rgba(99,102,241,0.1)', borderRadius: '12px', fontSize: '12px' }}>{word}</span>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            ))}
            {Object.keys(profiles).length === 0 && <div style={{ backgroundColor: '#111118', borderRadius: '16px', padding: '60px 20px', border: '1px solid rgba(99,102,241,0.2)', textAlign: 'center' }}><div style={{ fontSize: '48px', marginBottom: '16px' }}>üë•</div><h3 style={{ margin: '0 0 8px' }}>No Profiles</h3><p style={{ margin: 0, color: '#64748b', fontSize: '14px' }}>Profiles build from conversations</p></div>}
          </div>
        )}
      </main>

      <style>{`
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        input:focus, button:focus, select:focus { outline: none; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(99,102,241,0.3); border-radius: 3px; }
      `}</style>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>